{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title"},{"path":["body"],"id":"body","weight":1,"src":"body"}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"andesol / Notes","n":0.577},"1":{"v":"\n# Welcome to my notes\n\nHere you'll find a bunch of quick notes:\n\n- Unpolished\n- Sometimes incorrect\n- Maybe not even in English.\n","n":0.224}}},{"i":2,"$":{"0":{"v":"Languages","n":1},"1":{"v":"\nI mean: programming languages\n","n":0.5}}},{"i":3,"$":{"0":{"v":"Haskell","n":1},"1":{"v":"\nGHCI\n\n- `:t (:type)`\n- `:r (:reload)`\n","n":0.447}}},{"i":4,"$":{"0":{"v":"Types","n":1},"1":{"v":"\nIt's a good practice in Haskell to write explicitly the types and not to rely exclusively on inference.\n\n## Basic Types\n\n- Bool\n- Char\n- String\n- Int\n- Float\n\n## List Types\n\nList is a sequence of values of the same type\n\n```hs\n[False, True, False] :: [Bool]\n['a', ['b', 'c']] :: [Char]\n```\n\n## Tuples\n\nA tuple is a sequence of values of different **types**\n\n```hs\n(False, True) :: (Bool, Bool)\n(False, 'a', True) :: (Bool, Char, Bool)\n```\n\nThe type of a tuple encodes it's size (unlike lists). Types unrestricted.\n\n```hs\n('a', (False, 'b')) :: (Char, (Bool, Char))\n(True, ['a', 'b']) :: (Bool, [Char])\n```\n\n## Function Types\n\nA function is a mapping between two types\n\n```\nnot :: Bool -> Bool\n```\n\n- Polymorphic functions:\n\na ~= any (or b or c), p. e:\n\n```\nlength :: [a] -> Int\n```\n\n- Overloaded functions: a polymorphic function is overloaded if its type contain one or more class constrainsts, e.g.\n\n```\n(+) :: Num a => a -> a -> a\n```\n\n(a has to be a numberic type)\n\n- Num: Numeric types (+)\n- Eq: equality types (==)\n- Ord: ordered types (<)\n\n## Type declarations\n\n```hs\ntype Pos = (Int, Int)\n\norigin :: Pos\norigin = (0,0)\n\nleft :: Pos -> Pos\nleft (x,y) = (x-1,y)\n```\n\nWe can use params:\n\n```hs\ntype Pair a = (a, a)\n\n\nmult:: Pair Int -> Int\nmult (m,n) = m*n\n```\n","n":0.073}}},{"i":5,"$":{"0":{"v":"Set Up","n":0.707},"1":{"v":"\n- https://www.haskell.org/ghcup/\n\n- https://docs.haskellstack.org/en/stable/README/\n","n":0.577}}},{"i":6,"$":{"0":{"v":"Resources","n":1},"1":{"v":"\n- [A history of Haskell (video)](https://www.youtube.com/watch?v=3bjXGrycMhQ)\n\n- [Learn you a Haskell](http://learnyouahaskell.com/chapters)\n\n- [Functional programming in Haskell](https://www.youtube.com/watch?v=a0fPHkzK36I&list=PLF1Z-APd9zK7usPMx3LGMZEHrECUGodd3&index=1)\n\n- [Helsinki University Haskell](MOOChttps://haskell.mooc.fi/)\n","n":0.243}}},{"i":7,"$":{"0":{"v":"Recursion","n":1},"1":{"v":"\n## Why is it useful?\n\nSome functions are simpler to write in terms of other functions (e.g. factorial)\n\nProperties of functions using recursion may be proved using a mathematical technique call **induction**.\n\n```hs\nlength [] = 1\nlenght [_:xs] = 1 + length xs\n```\n\n## How to think recursively\n\n1. Write the type of the function\n2. Enumerate the cases, e.g. empty list etc.\n3. Generalise and simplify\n","n":0.13}}},{"i":8,"$":{"0":{"v":"High order functions","n":0.577},"1":{"v":"\nUseful?\n\n- Domain specific languages can be defined as collections of higher-order functions.\n\n- We can use albgebraic reasoning to understand programs.\n\n## Map\n\n```hs\nmap :: (a -> b) -> [a] -> [b]\n\n> map (+1) [1,3, 4]\n> [2,4,5]\n```\n\n## Filter\n\n```hs\nfilter :: (a -> Bool) -> [a] -> [a]\n\n> filter even [1,3,4]\n> [4]\n```\n\n## Foldr\n\n```hs\n-- Pattern\nf [] = v\nf (x:xs) = x âŠ• f xs\n\n\n--Example\nsum [] = 0\nsum (x:xs) = x + sum xs\n\nproduct [] = 1\nproduct (x:xs) = x * product xs\n\nand [] = True\nand (x:xs) = x && and xs\n\n\n-- These operations can be defined using foldr (hof)\nsum = foldr (+) 0\nproduct = foldr (*) 1\n...\n```\n","n":0.1}}},{"i":9,"$":{"0":{"v":"Curry","n":1},"1":{"v":"\nCurried functions are more flexible, because the can be partially applied.\n\nCurrying conventions\n\n- The arrow associates to the right.\n\n```hs\nInt -> Int -> Int\n```\n\nMeans:\n\n```hs\nInt -> (Int -> Int)\n```\n","n":0.196}}},{"i":10,"$":{"0":{"v":"Conditional","n":1},"1":{"v":"\n## if ... then ... else\n\n```hs\nabs :: Int -> Int\nabs n = if n >= 0 then n else -n\n```\n\nAlternatively:\n\n## Guarded Equations\n\n```hs\nabs n | n >= 0    = n\n      | otherwise = -n\n```\n\n## Pattern Matching\n\n```hs\nnot :: Bool -> Bool\nnot False = True\nnot True = False\n```\n","n":0.149}}},{"i":11,"$":{"0":{"v":"Code Examples","n":0.707},"1":{"v":"\n## Quick sort\n\n```hs\nqsort :: Ord a => [a] -> [a]\nqsort []    = []\nqsort(x:xs) =\n    qsort smaller ++ [x] ++ qsort larger\n    where\n        smaller = [a | a <- xs, a <=x]\n        larger  = [b | b <- xs, b > x]\n```\n\nTaken from [this video](https://www.youtube.com/watch?=WawJ8LArl54&list=PLF1Z-APd9zK7usPMx3LGMZEHrECUGodd3)\n","n":0.151}}},{"i":12,"$":{"0":{"v":"Basic Syntax","n":0.707},"1":{"v":"\n## Conventions\n\n- Function application has higher priority than the other operators.\n\n```hs\nf a + b === (f a) + b\n```\n\n- List arguments have an \"s\" at the end:\n\ne.g. `xs, ns, nss`\n","n":0.183}}},{"i":13,"$":{"0":{"v":"Functional Programming","n":0.707},"1":{"v":"\nFor a brief historical intro check [this video](https://www.youtube.com/watch?v=rIprO6zoujM&list=PLF1Z-APd9zK7usPMx3LGMZEHrECUGodd3)\n\nSee:\n\n- [[lang.haskell]]\n","n":0.333}}},{"i":14,"$":{"0":{"v":"Daily","n":1}}}]}
